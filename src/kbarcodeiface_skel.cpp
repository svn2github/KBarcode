/****************************************************************************
**
** DCOP Skeleton generated by dcopidl2cpp from kbarcodeiface.kidl
**
** WARNING! All changes made in this file will be lost!
**
*****************************************************************************/

#include "/home/dominik/Desktop/Programming/kbarcode/kbarcode/kbarcodeiface.h"

#include <kdatastream.h>
#include <qasciidict.h>


static const int KBarcodeIface_fhash = 13;
static const char* const KBarcodeIface_ftable[13][3] = {
    { "void", "startBarcode()", "startBarcode()" },
    { "void", "startLabelEditor()", "startLabelEditor()" },
    { "void", "startBatchPrint()", "startBatchPrint()" },
    { "void", "editArticles()", "editArticles()" },
    { "void", "editCustomers()", "editCustomers()" },
    { "void", "editCustomerText()", "editCustomerText()" },
    { "void", "editLabelDef()", "editLabelDef()" },
    { "void", "importCSV()", "importCSV()" },
    { "bool", "isSQLConnected()", "isSQLConnected()" },
    { "bool", "connectSQL()", "connectSQL()" },
    { "void", "showWizard()", "showWizard()" },
    { "void", "showConfigure()", "showConfigure()" },
    { 0, 0, 0 }
};
static const int KBarcodeIface_ftable_hiddens[12] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool KBarcodeIface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    static QAsciiDict<int>* fdict = 0;
    if ( !fdict ) {
	fdict = new QAsciiDict<int>( KBarcodeIface_fhash, true, false );
	for ( int i = 0; KBarcodeIface_ftable[i][1]; i++ )
	    fdict->insert( KBarcodeIface_ftable[i][1],  new int( i ) );
    }
    int* fp = fdict->find( fun );
    switch ( fp?*fp:-1) {
    case 0: { // void startBarcode()
	replyType = KBarcodeIface_ftable[0][0]; 
	startBarcode( );
    } break;
    case 1: { // void startLabelEditor()
	replyType = KBarcodeIface_ftable[1][0]; 
	startLabelEditor( );
    } break;
    case 2: { // void startBatchPrint()
	replyType = KBarcodeIface_ftable[2][0]; 
	startBatchPrint( );
    } break;
    case 3: { // void editArticles()
	replyType = KBarcodeIface_ftable[3][0]; 
	editArticles( );
    } break;
    case 4: { // void editCustomers()
	replyType = KBarcodeIface_ftable[4][0]; 
	editCustomers( );
    } break;
    case 5: { // void editCustomerText()
	replyType = KBarcodeIface_ftable[5][0]; 
	editCustomerText( );
    } break;
    case 6: { // void editLabelDef()
	replyType = KBarcodeIface_ftable[6][0]; 
	editLabelDef( );
    } break;
    case 7: { // void importCSV()
	replyType = KBarcodeIface_ftable[7][0]; 
	importCSV( );
    } break;
    case 8: { // bool isSQLConnected()
	replyType = KBarcodeIface_ftable[8][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << isSQLConnected( );
    } break;
    case 9: { // bool connectSQL()
	replyType = KBarcodeIface_ftable[9][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << connectSQL( );
    } break;
    case 10: { // void showWizard()
	replyType = KBarcodeIface_ftable[10][0]; 
	showWizard( );
    } break;
    case 11: { // void showConfigure()
	replyType = KBarcodeIface_ftable[11][0]; 
	showConfigure( );
    } break;
    default: 
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList KBarcodeIface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "KBarcodeIface";
    return ifaces;
}

QCStringList KBarcodeIface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; KBarcodeIface_ftable[i][2]; i++ ) {
	if (KBarcodeIface_ftable_hiddens[i])
	    continue;
	QCString func = KBarcodeIface_ftable[i][0];
	func += ' ';
	func += KBarcodeIface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


